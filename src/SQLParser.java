import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Objects;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SQLParser {
    private final File path;
    private final ArrayList<SQLProcedure> procedures;
    private final ArrayList<SQLTable> tables;
    private final String title;
    final private Pattern docPattern = Pattern.compile(
            "/\\*\\*(?:\\s+|\\n+)?(?<comment>(?:[^/]+)+)\\*/\\n?CREATE\\s+(?<type>\\S+)\\s+(?<name>[^\\s()]+)(?:\\s+)?\\(\\n?(?<args>(?:[^)].+\\n+)+)?\\)",
            Pattern.CASE_INSENSITIVE);
    final private Pattern triggerPattern = Pattern.compile("/\\*\\*(?:\\s+|\\n+)?(?<comment>(?:[^/]+)+)\\*/\\n?CREATE\\s+(?<type>TRIGGER)\\s+(?<name>[^\\s()]+)(?:\\n|\\s)+(?<when>(?:AFTER|BEFORE)(?:\\n|\\s)+\\S+)(?:\\n|\\s)+ON(?:\\s|\\n)+(?<table>\\S+)");
    private int fileCount;
    private int procedureCount;
    private int tableCount;
    private boolean quietMode;
    private int triggerCount;

    public SQLParser(final File file, String newTitle) {
        path = file;
        procedures = new ArrayList<>();
        tables = new ArrayList<>();
        fileCount = 0;
        procedureCount = 0;
        tableCount = 0;
        triggerCount = 0;
        quietMode = false;
        title = newTitle;
    }

    public void parse(boolean quiet) throws FileNotFoundException {
        quietMode = quiet;

        parse(path);

        Collections.sort(tables);
        Collections.sort(procedures);

        if (!quietMode)
            System.out.println("Finished reading " + fileCount + " file" + (fileCount > 1 ? 's' : "") + '.');
    }

    public void parse(final File file) throws FileNotFoundException, NullPointerException {
        if (file.isDirectory()) {
            for (File f : Objects.requireNonNull(file.listFiles(), "No files in directory")) {
                parse(f);
            }
        } else {
            ++fileCount;
            procedureCount = 0;
            tableCount = 0;
            triggerCount = 0;
            processFile(file);
        }
    }

    public void print() {
        System.out.println();

        System.out.println("\033[1;4;96mTABLES\033[0m\n");

        for (SQLTable t : tables) {
            System.out.println(t.toString());
        }

        System.out.println("\033[1;4;96mPROCEDURES\033[0m\n");

        for (SQLProcedure p : procedures) {
            System.out.println(p.toString());
        }
    }

    public void printMD(String location) throws IOException {
        if (procedures.isEmpty() && tables.isEmpty()) {
            if (!quietMode) {
                System.out.println("No SQLDoc was found. Not outputting to file.");
            }
            return;
        }

        boolean hideCredits = SQLDocSettings.getSetting("hide-credits").equals("true");
        boolean hideTables = SQLDocSettings.getSetting("hide-tables").equals("true");
        boolean hideProcedures = SQLDocSettings.getSetting("hide-procedures").equals("true");
        if (!location.endsWith(".md"))
            location += ".md";
        FileWriter fw = new FileWriter(location);
        BufferedWriter bw = new BufferedWriter(fw);
        PrintWriter output = new PrintWriter(bw);
        System.out.println();

        output.printf("# %s%n%n", title);
        if (!hideCredits)
            output.println(
                    "This documentation was automatically generated by [SQLDoc](https://github.com/isaacmaddox/SQLDoc)\n");

        output.println(tableOfContentsMD());

        if (!tables.isEmpty() && !hideTables) {
            output.println("# Tables");

            for (SQLTable t : tables) {
                output.println(t.toMD());
            }
        }

        if (!procedures.isEmpty() && !hideProcedures) {
            output.println("# Procedures");

            for (SQLProcedure p : procedures) {
                output.println(p.toMD());
            }
        }

        if (!hideCredits)
            output.println("\n---\n[Check out SQLDoc on Github](https://github.com/isaacmaddox/SQLDoc)");

        output.close();

        if (!quietMode)
            System.out.printf("Finished writing to %s", location);
    }

    private String tableOfContentsMD() {
        int max_size = Math.max(tables.size(), procedures.size());
        StringBuilder sb = new StringBuilder("# Table of Contents\n");

        sb.append(new SQLEntity().mdTableHeader("Tables", "Procedures"));

        for (int i = 0; i < max_size; ++i) {
            sb.append("| ");
            if (tables.size() >= i + 1) {
                sb.append(String.format("%s | ", tables.get(i).getMDLink()));
            } else
                sb.append("| ");

            if (procedures.size() >= i + 1) {
                sb.append(String.format("%s | ", procedures.get(i).getMDLink()));
            } else
                sb.append("| |");

            sb.append("\n");
        }

        return sb.toString();
    }

    private void processFile(final File file) throws FileNotFoundException {
        Scanner inputFR = new Scanner(new FileReader(file));
        String path = file.getAbsolutePath();
        String ext = path.substring(path.lastIndexOf('.') + 1);

        // File is not the right type
        if (!ext.equals("sql"))
            return;
        String line;
        String buffer = "";

        while (inputFR.hasNextLine()) {
            line = inputFR.nextLine();

            // Ignore lines that don't start with a SQLDoc comment if we have not already found one
            if (!line.trim().startsWith("/**") && buffer.isEmpty()) {
                continue;
            }

            // Add line to the buffer
            buffer += (!buffer.isEmpty() ? "\n" : "") + line;

            Matcher docMatcher = docPattern.matcher(buffer);
            Matcher triggerMatcher = triggerPattern.matcher(buffer);

            // Test the buffer for a match for the regex expressions to match comments.
            if (docMatcher.find()) {
                processDoc(docMatcher.group("name"), docMatcher.group("type"), docMatcher.group("comment"), docMatcher.group("args"));
                buffer = "";
            } else if (triggerMatcher.find()) {
                processDoc(triggerMatcher.group("name"), triggerMatcher.group("type"), triggerMatcher.group("comment"), triggerMatcher.group("when"), triggerMatcher.group("table"));
                buffer = "";
            }
        }

        inputFR.close();
        if (quietMode) return;

        if (tableCount > 0)
            System.out.printf("[%s] Found %d tables%n", file.getName(), tableCount);
        if (procedureCount > 0)
            System.out.printf("[%s] Found %d procedures%n", file.getName(), procedureCount);
        if (triggerCount > 0)
            System.out.printf("[%s] Found %d triggers%n", file.getName(), triggerCount);
    }

    private void processDoc(final String name, final String type, final String comment, final String... args) {
        switch (type.toUpperCase()) {
            case "PROCEDURE":
                ++procedureCount;
                procedures.add(new SQLProcedure(name, comment, args[0]));
                break;
            case "TABLE":
                ++tableCount;
                tables.add(new SQLTable(name, comment, args[0]));
                break;
            case "TRIGGER":
                if (args.length < 2) return;
                ++triggerCount;
                addTriggerToTable(new SQLTrigger(name, comment, args[0], args[1]), args[1]);
                break;
        }
    }

    private void addTriggerToTable(SQLTrigger t, String tblName) {
        for (SQLTable table : tables) {
            if (table.getName().equals(tblName)) {
                table.addTrigger(t);
                break;
            }
        }
    }
}
