import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.ArrayList;

public class SQLParser {
	private File path;
	private ArrayList<SQLProcedure> procedures;
	private ArrayList<SQLTable> tables;
	private int fileCount;
	private int procCount;
	private int tableCount;
	private String title;
	final private Pattern docPattern = Pattern.compile("\\/\\*\\*(?:\\s+|\\n+)?(?<comment>(?:[^/]+){1,})\\*\\/(?:\\n)?CREATE(?:\\s+)(?<type>\\S+)(?:\\s+)(?<name>[^\\s()]+)(?:\\s+)?\\((?:\\n)?(?<args>(?:[^)].+\\n+){1,})?\\)", Pattern.CASE_INSENSITIVE);
	private boolean quietMode;
	
	public SQLParser(final File file, String newTitle) {
		path = file;
		procedures = new ArrayList<SQLProcedure>();
		tables = new ArrayList<SQLTable>();
		fileCount = 0;
		procCount = 0;
		tableCount = 0;
		quietMode = false;
		title = newTitle;
	}
	
	public void parse(boolean quiet) {
	   quietMode = quiet;
	   
		parse(path);
		
		if (!quietMode)
		   System.out.println("Finished reading " + fileCount + " file" + (fileCount > 1 ? 's' : "") + '.');
	}
	
	public void parse(final File file) {
		if (file.isDirectory()) {
			for (File f : file.listFiles()) {
				parse(f);
			}
		} else {
			++fileCount;
			procCount = 0;
			tableCount = 0;
			processFile(file);
		}
	}
	
	public void print() {
		System.out.println();
		
		for (SQLProcedure p : procedures) {
			System.out.println(p.toString());
		}
		
		for (SQLTable t : tables) {
		   System.out.println(t.toString());
		}
	}
	
	public void printMD(String location) {
	   try {
	      if (!location.endsWith(".md")) location += ".md";
	      FileWriter fw = new FileWriter(location);
	      BufferedWriter bw = new BufferedWriter(fw);
	      PrintWriter output = new PrintWriter(bw);
   	   System.out.println();
   	   
   	   output.println("# " + title);
   	   output.println("This documentation was automatically generated by [SQLDoc](https://github.com/isaacmaddox/SQLDoc)\n");
   	   
   	   output.println(tableOfContentsMD());
   	   
   	   if (tables.size() > 0) {
      	   output.println("# Tables");
      	   
      	   for (SQLTable t : tables) {
      	      output.println(t.toMD());
      	   }
   	   }
   	   
   	   if (procedures.size() > 0) {
      	   output.println("# Procedures");
      	      	      	   
      	   for (SQLProcedure p : procedures) {
      	      output.println(p.toMD());
      	   }
   	   }
   	   
   	   output.println("\n---\n[Check out SQLDoc on Github](https://github.com/isaacmaddox/SQLDoc)");
   	   
   	   output.close();
   	   
   	   if (!quietMode)
   	      System.out.println("Finished writing to " + location);
	   } catch (Exception e) {
	      SQLDocDriver.printError(String.format("SQLDoc ran into an error:%n\t%s", e.getMessage()));
	   }
	}
	
	private String tableOfContentsMD() {
	   int max_size = Math.max(tables.size(), procedures.size());
	   StringBuilder sb = new StringBuilder("# Table of Contents\n");
	   
	   sb.append(SQLEntity.mdTableHeaderS("Tables", "Procedures"));
	   
	   for (int i = 0; i < max_size - 1; ++i) {
	      sb.append("| ");
	      if (tables.size() > i + 1) {
	         sb.append(String.format("%s | ", tables.get(i).getMDLink()));
	      } else sb.append("| ");
	      
	      if (procedures.size() > i + 1) {
	         sb.append(String.format("%s | ", procedures.get(i).getMDLink()));
	      } else sb.append("| |");
	      
	      sb.append("\n");
	   }
	   
	   return sb.toString();
	}
	
	private void processFile(final File file) {
		try {
   	   String path = file.getAbsolutePath();
   	   String ext = path.substring(path.lastIndexOf('.') + 1);
   	   
   	   if (!ext.equals("sql")) return;
   	   
   		Scanner inputFR = new Scanner(file);
   		String line = "";
   		String buffer = "";
   		
   		while (inputFR.hasNextLine()) {
   			line = inputFR.nextLine();
   			
   			if (!line.trim().startsWith("/**") && buffer.isEmpty()) {
   				continue;
   			}
   								
   			buffer += (!buffer.isEmpty() ? "\n" : "") + line;
   			
   			
   			Matcher m = docPattern.matcher(buffer);
   			boolean matches = m.find();
   			
   			if (!matches) {
   				continue;
   			} else {
   				processDoc(m.group("name"), m.group("type"), m.group("comment"), m.group("args"));
   				buffer = "";
   			}
   		}
   		
   		inputFR.close();
   		if (procCount > 0 && !quietMode)
   		   System.out.println("[" + file.getName() + "] Found " + procCount + " procedures");
   		if (tableCount > 0 && !quietMode) {
   		   System.out.println("[" + file.getName() + "] Found " + tableCount + " tables");
   		}
		} catch (FileNotFoundException e) {
			System.out.println("Couldn't find file");
		}
	}
	
	private void processDoc(final String name, final String type, final String comment, final String args) {		
		switch (type.toUpperCase()) {
		case "PROCEDURE":
			++procCount;
			procedures.add(new SQLProcedure(name, comment, args));
			break;
		case "TABLE":
		   ++tableCount;
		   tables.add(new SQLTable(name, comment, args));
		   break;
		}
	}
}
