import java.io.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class SQLParser {
    private final File path;
    private final ArrayList<SQLProcedure> procedures;
    private final ArrayList<SQLTable> tables;
    private final ArrayList<SQLTrigger> triggers;
    private final String title;
    final private Pattern docPattern = Pattern.compile(
            "/\\*\\*(?:\\s+|\\n+)?(?<comment>(?:[^/]+)+)\\*/\\n?CREATE\\s+(?<type>\\S+)\\s+(?<name>[^\\s()]+)(?:\\s+)?\\(\\n?(?<args>(?:[^)].+\\n+)+)?\\)",
            Pattern.CASE_INSENSITIVE);
    final private Pattern triggerPattern = Pattern.compile("/\\*\\*(?:\\s+|\\n+)?(?<comment>(?:[^/]+)+)\\*/\\n?CREATE\\s+(?<type>TRIGGER)\\s+(?<name>[^\\s()]+)(?:\\n|\\s)+(?<when>(?:AFTER|BEFORE)(?:\\n|\\s)+\\S+)(?:\\n|\\s)+ON(?:\\s|\\n)+(?<table>\\S+)");
    private int fileCount;
    private int procCount;
    private int tableCount;
    private boolean quietMode;
    private int triggerCount;

    public SQLParser(final File file, String newTitle) {
        path = file;
        procedures = new ArrayList<SQLProcedure>();
        tables = new ArrayList<SQLTable>();
        triggers = new ArrayList<SQLTrigger>();
        fileCount = 0;
        procCount = 0;
        tableCount = 0;
        triggerCount = 0;
        quietMode = false;
        title = newTitle;
    }

    public void parse(boolean quiet) {
        quietMode = quiet;

        parse(path);

        Collections.sort(tables);
        Collections.sort(procedures);
        Collections.sort(triggers);

        if (!quietMode)
            System.out.println("Finished reading " + fileCount + " file" + (fileCount > 1 ? 's' : "") + '.');
    }

    public void parse(final File file) {
        if (file.isDirectory()) {
            for (File f : file.listFiles()) {
                parse(f);
            }
        } else {
            ++fileCount;
            procCount = 0;
            tableCount = 0;
            triggerCount = 0;
            processFile(file);
        }
    }

    public void print() {
        System.out.println();

        System.out.println("\033[1;4;96mTABLES\033[0m\n");

        for (SQLTable t : tables) {
            System.out.println(t.toString());
        }

        System.out.println("\033[1;4;96mPROCEDURES\033[0m\n");

        for (SQLProcedure p : procedures) {
            System.out.println(p.toString());
        }

        System.out.println("\033[1;4;96mTRIGGERS\033[0m\n");

        for (SQLTrigger t : triggers) {
            System.out.println(t.toString());
        }
    }

    public void printMD(String location) {
        try {
            if (!location.endsWith(".md"))
                location += ".md";
            FileWriter fw = new FileWriter(location);
            BufferedWriter bw = new BufferedWriter(fw);
            PrintWriter output = new PrintWriter(bw);
            System.out.println();

            output.println("# " + title);
            output.println(
                    "This documentation was automatically generated by [SQLDoc](https://github.com/isaacmaddox/SQLDoc)\n");

            output.println(tableOfContentsMD());

            if (!tables.isEmpty()) {
                output.println("# Tables");

                for (SQLTable t : tables) {
                    output.println(t.toMD());
                }
            }

            if (!procedures.isEmpty()) {
                output.println("# Procedures");

                for (SQLProcedure p : procedures) {
                    output.println(p.toMD());
                }
            }

            if (!triggers.isEmpty()) {
                output.println("# Triggers");

                for (SQLTrigger t : triggers) {
                    output.println(t.toMD());
                }
            }

            output.println("\n---\n[Check out SQLDoc on Github](https://github.com/isaacmaddox/SQLDoc)");

            output.close();

            if (!quietMode)
                System.out.println("Finished writing to " + location);
        } catch (Exception e) {
            SQLDocDriver.printError(String.format("SQLDoc ran into an error:%n\t%s", e.getMessage()));
        }
    }

    private String tableOfContentsMD() {
        int max_size = Math.max(tables.size(), Math.max(procedures.size(), triggers.size()));
        StringBuilder sb = new StringBuilder("# Table of Contents\n");

        sb.append(new SQLEntity().mdTableHeader("Tables", "Procedures", "Triggers"));

        for (int i = 0; i < max_size; ++i) {
            sb.append("| ");
            if (tables.size() >= i + 1) {
                sb.append(String.format("%s | ", tables.get(i).getMDLink()));
            } else
                sb.append("| ");

            if (procedures.size() >= i + 1) {
                sb.append(String.format("%s | ", procedures.get(i).getMDLink()));
            } else
                sb.append("| ");

            if (triggers.size() >= i + 1) {
                sb.append(String.format("%s | ", triggers.get(i).getMDLink()));
            } else
                sb.append("| |");

            sb.append("\n");
        }

        return sb.toString();
    }

    private void processFile(final File file) {
        try {
            String path = file.getAbsolutePath();
            String ext = path.substring(path.lastIndexOf('.') + 1);

            if (!ext.equals("sql"))
                return;

            Scanner inputFR = new Scanner(file);
            String line;
            String buffer = "";

            while (inputFR.hasNextLine()) {
                line = inputFR.nextLine();

                if (!line.trim().startsWith("/**") && buffer.isEmpty()) {
                    continue;
                }

                buffer += (!buffer.isEmpty() ? "\n" : "") + line;

                Matcher docMatcher = docPattern.matcher(buffer);
                Matcher triggerMatcher = triggerPattern.matcher(buffer);

                if (docMatcher.find()) {
                    processDoc(docMatcher.group("name"), docMatcher.group("type"), docMatcher.group("comment"), docMatcher.group("args"));
                    buffer = "";
                } else if (triggerMatcher.find()) {
                    processDoc(triggerMatcher.group("name"), triggerMatcher.group("type"), triggerMatcher.group("comment"), triggerMatcher.group("when"), triggerMatcher.group("table"));
                    buffer = "";
                }
            }

            inputFR.close();
            if (quietMode) return;

            if (tableCount > 0)
                System.out.printf("[%s] Found %d tables%n", file.getName(), tableCount);
            if (procCount > 0)
                System.out.printf("[%s] Found %d procedures%n", file.getName(), procCount);
            if (triggerCount > 0)
                System.out.printf("[%s] Found %d triggers%n", file.getName(), triggerCount);

        } catch (FileNotFoundException e) {
            SQLDocDriver.printError("Couldn't find file");
        }
    }

    private void processDoc(final String name, final String type, final String comment, final String... args) {
        switch (type.toUpperCase()) {
            case "PROCEDURE":
                ++procCount;
                procedures.add(new SQLProcedure(name, comment, args[0]));
                break;
            case "TABLE":
                ++tableCount;
                tables.add(new SQLTable(name, comment, args[0]));
                break;
            case "TRIGGER":
                if (args.length < 2) return;
                ++triggerCount;
                triggers.add(new SQLTrigger(name, comment, args[0], args[1]));
                break;
        }
    }
}
